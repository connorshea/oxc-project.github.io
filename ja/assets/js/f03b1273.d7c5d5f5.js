"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[483],{9318:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=t(1527),r=t(7660);const i={id:"learn_performance",title:"Pursuit of Performance"},a="Pursuit of Performance on Building a JavaScript Compiler",o={id:"learn/learn_performance",title:"Pursuit of Performance",description:"Originally posted on https://rustmagazine.org/issue-3/javascript-compiler/",source:"@site/docs/learn/performance.md",sourceDirName:"learn",slug:"/learn/learn_performance",permalink:"/ja/docs/learn/learn_performance",draft:!1,unlisted:!1,editUrl:"https://github.com/oxc-project/oxc-project.github.io/tree/main/docs/learn/performance.md",tags:[],version:"current",frontMatter:{id:"learn_performance",title:"Pursuit of Performance"},sidebar:"learn",previous:{title:"Grammar",permalink:"/ja/docs/learn/ecmascript/grammar"},next:{title:"Swc",permalink:"/ja/docs/learn/swc"}},l={},c=[{value:"On Performance",id:"on-performance",level:2},{value:"Abstract Syntax Tree (AST)",id:"abstract-syntax-tree-ast",level:2},{value:"Memory Allocation",id:"memory-allocation",level:3},{value:"Enum Sizes",id:"enum-sizes",level:3},{value:"Span",id:"span",level:3},{value:"Strings and Identifiers",id:"strings-and-identifiers",level:3},{value:"String interning",id:"string-interning",level:3},{value:"string-cache",id:"string-cache",level:4},{value:"String Inlining",id:"string-inlining",level:3},{value:"Lexer",id:"lexer",level:2},{value:"Token",id:"token",level:3},{value:"Cow",id:"cow",level:3},{value:"SIMD",id:"simd",level:3},{value:"Keyword match",id:"keyword-match",level:3},{value:"Linter",id:"linter",level:2},{value:"Parent Pointing Tree",id:"parent-pointing-tree",level:3},{value:"Processing files in parallel",id:"processing-files-in-parallel",level:3},{value:"Printing is slow",id:"printing-is-slow",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"pursuit-of-performance-on-building-a-javascript-compiler",children:"Pursuit of Performance on Building a JavaScript Compiler"}),"\n",(0,s.jsxs)(n.p,{children:["Originally posted on ",(0,s.jsx)(n.a,{href:"https://rustmagazine.org/issue-3/javascript-compiler/",children:"https://rustmagazine.org/issue-3/javascript-compiler/"})]}),"\n",(0,s.jsx)(n.h2,{id:"on-performance",children:"On Performance"}),"\n",(0,s.jsxs)(n.p,{children:["After two years of writing Rust, performance has become an ingrained discipline for me - it boils down to\n",(0,s.jsx)(n.strong,{children:"allocate less memory"})," and ",(0,s.jsx)(n.strong,{children:"use fewer CPU cycles"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"However, achieving optimal performance can be difficult without the knowledge of the problem domain or awareness of potential solutions."}),"\n",(0,s.jsx)(n.p,{children:"I will take you on my journey of performance and optimization in the following sections.\nMy preferred method of learning is through a combination of research, trial, and error,\nso the following sections will be organized as such."}),"\n",(0,s.jsx)(n.h1,{id:"parsing",children:"Parsing"}),"\n",(0,s.jsx)(n.p,{children:"Oxc is a standard compiler that includes an abstract syntax tree (AST), a lexer, and a recursive descent parser."}),"\n",(0,s.jsx)(n.h2,{id:"abstract-syntax-tree-ast",children:"Abstract Syntax Tree (AST)"}),"\n",(0,s.jsx)(n.p,{children:"The first architectural design for a compiler is its AST."}),"\n",(0,s.jsx)(n.p,{children:"All JavaScript tools work on the AST level, for example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A linter (e.g. ESLint) checks the AST for errors"}),"\n",(0,s.jsx)(n.li,{children:"A formatter (e.g.prettier) prints the AST back to JavaScript text"}),"\n",(0,s.jsx)(n.li,{children:"A minifier (e.g. terser) transforms the AST"}),"\n",(0,s.jsx)(n.li,{children:"A bundler connects all import and export statements between ASTs from different files"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It will be painful to build these tools if the AST is not user-friendly."}),"\n",(0,s.jsxs)(n.p,{children:["For JavaScript, the most used AST specification is ",(0,s.jsx)(n.a,{href:"https://github.com/estree/estree",children:"estree"}),".\nMy first AST version replicates estree:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct Program {\n    pub node: Node,\n    pub body: Vec<Statement>,\n}\n\npub enum Statement {\n    VariableDeclarationStatement(VariableDeclaration),\n}\n\npub struct VariableDeclaration {\n    pub node: Node,\n    pub declarations: Vec<VariableDeclarator>,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"In Rust, declaring a tree is relatively straightforward, as it involves using structs and enums."}),"\n",(0,s.jsx)(n.h3,{id:"memory-allocation",children:"Memory Allocation"}),"\n",(0,s.jsxs)(n.p,{children:["I worked on this version of AST for a couple of months while writing the parser.\nAnd one day I decided to profile it. The profiler showed the program was spending a lot of time calling ",(0,s.jsx)(n.code,{children:"drop"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["\ud83d\udca1 Nodes of the AST are allocated on the heap via ",(0,s.jsx)(n.code,{children:"Box"})," or ",(0,s.jsx)(n.code,{children:"Vec"}),", they are allocated individually so they are dropped in sequential order."]}),"\n",(0,s.jsx)(n.p,{children:"Is there a solution to mitigate this?"}),"\n",(0,s.jsxs)(n.p,{children:["So while working on the parser I studied some of the other JavaScript parsers written in Rust,\nmainly ",(0,s.jsx)(n.a,{href:"https://github.com/ratel-rust/ratel-core",children:"ratel"})," and ",(0,s.jsx)(n.a,{href:"https://github.com/mozilla-spidermonkey/jsparagus",children:"jsparagus"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Both of these parsers declare their AST with a lifetime annotation,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum Statement<'ast> {\n    Expression(ExpressionNode<'ast>),\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and they have an accompanying file called ",(0,s.jsx)(n.code,{children:"arena.rs"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["I did not understand what it does so I neglected them until I started reading about their usage of memory arenas:\n",(0,s.jsx)(n.a,{href:"https://docs.rs/bumpalo/latest/bumpalo/",children:"bumpalo"})," and ",(0,s.jsx)(n.a,{href:"https://docs.rs/toolshed/latest/toolshed/struct.Arena.html",children:"toolshed"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"In summary, memory arena allocates memory upfront in chunks or pages and deallocate altogether when the arena is dropped.\nThe AST is allocated on the arena so dropping the AST is a fast operation."}),"\n",(0,s.jsx)(n.p,{children:"Another nice side effect that comes with this is that,\nthe AST is constructed in a specific order, and tree traversal also follows the same order, resulting in linear memory access during the visitation process.\nThis access pattern will be efficient since all nearby memory will be read into the CPU cache in pages, resulting in faster access times."}),"\n",(0,s.jsxs)(n.p,{children:["Unfortunately it can be challenging for Rust beginners to use memory arenas because all data structures and relevant functions need to be parameterized by lifetime annotations.\nIt took me five attempts to allocate the AST inside ",(0,s.jsx)(n.code,{children:"bumpalo"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Changing to a memory arena for the AST resulted around 20% performance improvement."}),"\n",(0,s.jsx)(n.h3,{id:"enum-sizes",children:"Enum Sizes"}),"\n",(0,s.jsx)(n.p,{children:'Due to the recursive nature of ASTs, we need to define the types in a way to avoid the "recursive without indirection" error:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"error[E0072]: recursive types `Enum` and `Variant` have infinite size\n --\x3e crates/oxc_linter/src/lib.rs:1:1\n  |\n1 | enum Enum {\n  | ^^^^^^^^^\n2 |     Variant(Variant),\n  |             ------- recursive without indirection\n3 | }\n4 | struct Variant {\n  | ^^^^^^^^^^^^^^\n5 |     field: Enum,\n  |            ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n2 ~     Variant(Box<Variant>),\n3 | }\n4 | struct Variant {\n5 ~     field: Box<Enum>,\n"})}),"\n",(0,s.jsx)(n.p,{children:"There are two ways to do this. Either box the enum in the enum variant or box the struct field."}),"\n",(0,s.jsxs)(n.p,{children:["I found the same question in the Rust forum back in 2017,\n",(0,s.jsx)(n.a,{href:"https://users.rust-lang.org/t/is-there-a-better-way-to-represent-an-abstract-syntax-tree/9549/4",children:"Is there a better way to represent an abstract syntax tree?"})]}),"\n",(0,s.jsxs)(n.p,{children:["Aleksey (matklad) told us to box the enum variants to keep the ",(0,s.jsx)(n.code,{children:"Expression"})," enum small. But what does this mean?"]}),"\n",(0,s.jsx)(n.p,{children:"As it turns out, the memory layout of a Rust enum is dependent on the sizes of all its variants, its total byte size dependents on the largest variant.\nFor example, the following enum will take up 56 bytes (1 byte for the tag, 48 bytes for the payload, and 8 bytes for alignment)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"enum Enum {\n    A, // 0 byte payload\n    B(String), // 24 byte payload\n    C { first: String, last: String }, // 48 byte payload\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In a typical JavaScript AST, the ",(0,s.jsx)(n.code,{children:"Expression"})," enum holds 45 variants and the ",(0,s.jsx)(n.code,{children:"Statement"})," enum holds 20 variants. They take up more than 200 bytes if not boxed by enum variants.\nThese 200 bytes have to be passed around, and also accessed every time we do a ",(0,s.jsx)(n.code,{children:"matches!(expr, Expression::Variant(_))"})," check, which is not very cache friendly for performance."]}),"\n",(0,s.jsx)(n.p,{children:"So to make memory access efficient, it is best to box the enum variants."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://nnethercote.github.io/perf-book/type-sizes.html",children:"perf-book"})," describes additional info on how to find large types."]}),"\n",(0,s.jsx)(n.p,{children:"I also copied the test for restricting small enum sizes."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[cfg(all(target_arch = "x86_64", target_pointer_width = "64"))]\n#[test]\nfn no_bloat_enum_sizes() {\n    use std::mem::size_of;\n    use crate::ast::*;\n    assert_eq!(size_of::<Statement>(), 16);\n    assert_eq!(size_of::<Expression>(), 16);\n    assert_eq!(size_of::<Declaration>(), 16);\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Boxing the enum variants resulted around 10% speed-up."}),"\n",(0,s.jsx)(n.h3,{id:"span",children:"Span"}),"\n",(0,s.jsx)(n.p,{children:"Occasionally, we may not realize that a smaller memory footprint is possible until we spend some extra time examining the data structures."}),"\n",(0,s.jsxs)(n.p,{children:['In this instance, the leaf of all AST nodes contains a small data structure called the "span", which is used for storing the byte offset from the source text and comprises two ',(0,s.jsx)(n.code,{children:"usize"}),"s."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct Node {\n    pub start: usize,\n    pub end: usize,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It was ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/pull/4#pullrequestreview-1294538874",children:"pointed out to me"})," that I can safely change ",(0,s.jsx)(n.code,{children:"usize"})," to ",(0,s.jsx)(n.code,{children:"u32"}),"\nto reduce peak memory because larger than ",(0,s.jsx)(n.code,{children:"u32"})," is a 4GB file."]}),"\n",(0,s.jsxs)(n.p,{children:["Changing to ",(0,s.jsx)(n.code,{children:"u32"})," improved the performance ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/pull/31",children:"up to 5% performance on large files"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"strings-and-identifiers",children:"Strings and Identifiers"}),"\n",(0,s.jsx)(n.p,{children:"Inside the AST, one may attempt to use a string reference to the source text for identifier names and string literals."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct StringLiteral<'a> {\n    pub value: &'a str,\n}\n\npub struct Identifier<'a> {\n    pub name: &'a str,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["But unfortunately in JavaScript, strings and identifiers can have ",(0,s.jsx)(n.a,{href:"https://mathiasbynens.be/notes/javascript-escapes",children:"escape sequences"}),",\ni.e. ",(0,s.jsx)(n.code,{children:"'\\251'"}),", ",(0,s.jsx)(n.code,{children:"'\\xA9'"})," and ",(0,s.jsx)(n.code,{children:"'\xa9'"})," are the same for the copyright symbol."]}),"\n",(0,s.jsxs)(n.p,{children:["This implies that we must compute the escaped values and allocate a new ",(0,s.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"string-interning",children:"String interning"}),"\n",(0,s.jsxs)(n.p,{children:["When there are lots of heap-allocated strings,\na technique called ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/String_interning",children:"string interning"})," can be used to reduce total memory by storing only one copy of each distinct string value."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://crates.io/crates/string_cache",children:"string-cache"})," is a popular and widely used library published by the servo team.\nInitially, I used the ",(0,s.jsx)(n.code,{children:"string-cache"})," library for identifiers and strings in the AST.\nThe performance of the parser was fast in a single thread,\nbut when I started implementing the linter where there are multiples parser running parallel with rayon,\nCPU utilization was at about 50% of all cores."]}),"\n",(0,s.jsxs)(n.p,{children:["Upon profiling, a method called ",(0,s.jsx)(n.code,{children:"parking_lot::raw_mutex::RawMutex::lock_slow"})," showed up on the top of the execution time.\nI did not know much about locks and multi-core programming,\nbut a global lock was just strange to start with,\nso I decided to remove the ",(0,s.jsx)(n.code,{children:"string-cache"})," library to enable full CPU utilization."]}),"\n",(0,s.jsxs)(n.p,{children:["Removing ",(0,s.jsx)(n.code,{children:"string-cache"})," from the AST improved the performance of parallel parsing by about 30%."]}),"\n",(0,s.jsx)(n.h4,{id:"string-cache",children:"string-cache"}),"\n",(0,s.jsxs)(n.p,{children:["Half a year later, while working on another performance-critical project,\nthe ",(0,s.jsx)(n.code,{children:"string-cache"})," library resurfaced again. It was blocking all the threads during parallel text parsing."]}),"\n",(0,s.jsxs)(n.p,{children:["I decided to study what ",(0,s.jsx)(n.code,{children:"string-cache"})," does because I am\nprepared this time after reading the book ",(0,s.jsx)(n.a,{href:"https://marabos.nl/atomics/",children:"Rust Atomics and Locks"})," by Mara Bos."]}),"\n",(0,s.jsxs)(n.p,{children:["Here are the\n",(0,s.jsx)(n.a,{href:"https://github.com/servo/string-cache/blob/6c044c91bb3d8212dae931152a7895f498574f71/src/dynamic_set.rs#L41-L42",children:"relevant"}),"\n",(0,s.jsx)(n.a,{href:"https://github.com/servo/string-cache/blob/6c044c91bb3d8212dae931152a7895f498574f71/src/atom.rs#L204",children:"code"}),"\naround the lock. Please note that the code was written eight years ago in 2015."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub(crate) static DYNAMIC_SET: Lazy<Mutex<Set>> = Lazy::new(|| {\n    Mutex::new({\n\n// ... in another place\nlet ptr: std::ptr::NonNull<Entry> =\n    DYNAMIC_SET.lock().insert(string_to_add, hash.g);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["So this is straightforward. It locks the data structure ",(0,s.jsx)(n.code,{children:"Set"})," every time a string is being inserted.\nAs this routine is called frequently within a parser, its performance is impacted negatively by synchronization."]}),"\n",(0,s.jsxs)(n.p,{children:["Now let's take a look at the ",(0,s.jsxs)(n.a,{href:"https://github.com/servo/string-cache/blob/6c044c91bb3d8212dae931152a7895f498574f71/src/dynamic_set.rs#L53-L86",children:[(0,s.jsx)(n.code,{children:"Set"})," data structure"]}),"\nand see what it does:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub(crate) fn insert(&mut self, string: Cow<str>, hash: u32) -> NonNull<Entry> {\n    let bucket_index = (hash & BUCKET_MASK) as usize;\n    {\n        let mut ptr: Option<&mut Box<Entry>> = self.buckets[bucket_index].as_mut();\n\n        while let Some(entry) = ptr.take() {\n            if entry.hash == hash && *entry.string == *string {\n                if entry.ref_count.fetch_add(1, SeqCst) > 0 {\n                    return NonNull::from(&mut **entry);\n                }\n                entry.ref_count.fetch_sub(1, SeqCst);\n                break;\n            }\n            ptr = entry.next_in_bucket.as_mut();\n        }\n    }\n    debug_assert!(mem::align_of::<Entry>() >= ENTRY_ALIGNMENT);\n    let string = string.into_owned();\n    let mut entry = Box::new(Entry {\n        next_in_bucket: self.buckets[bucket_index].take(),\n        hash,\n        ref_count: AtomicIsize::new(1),\n        string: string.into_boxed_str(),\n    });\n    let ptr = NonNull::from(&mut *entry);\n    self.buckets[bucket_index] = Some(entry);\n\n    ptr\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"It looks like it is looking for a bucket to store the string and it inserts the string if it is not in the bucket."}),"\n",(0,s.jsxs)(n.p,{children:["\ud83d\udca1 Is this linear probing? If this is linear probing then this ",(0,s.jsx)(n.code,{children:"Set"})," is just a ",(0,s.jsx)(n.code,{children:"HashMap"})," without saying it is a ",(0,s.jsx)(n.code,{children:"HashMap"}),".\n\ud83d\udca1 If this is a ",(0,s.jsx)(n.code,{children:"HashMap"}),", then ",(0,s.jsx)(n.code,{children:"Mutex<HashMap>"})," is a concurrent hashmap."]}),"\n",(0,s.jsx)(n.p,{children:"Although the solution may seem straightforward when we know what to look for, it took me a month to figure this out because I was unaware of the issue.\nWhen it became evident that this is just a concurrent hashmap, applying the Mutex to the buckets instead of the entire hashmap was a clear and logical solution.\nWithin an hour of implementing this change, I submitted a pull request and was happy with the outcome \ud83d\ude03."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-urlpreview",children:"https://github.com/servo/string-cache/pull/268\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It is worth mentioning that string interning is a battlefield within the Rust community.\nFor the example shown in ",(0,s.jsx)(n.a,{href:"https://dev.to/cad97/string-interners-in-rust-797",children:"this blog post"}),",\nthere are single-threaded libraries such ",(0,s.jsx)(n.code,{children:"string-interner"}),", ",(0,s.jsx)(n.code,{children:"lasso"}),", ",(0,s.jsx)(n.code,{children:"lalrpop-intern"}),", ",(0,s.jsx)(n.code,{children:"intaglio"})," and ",(0,s.jsx)(n.code,{children:"strena"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Since we are parsing files in parallel, an option is to utilize a multi-threaded string interner library such as ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/ustr",children:(0,s.jsx)(n.code,{children:"ustr"})}),".\nHowever, after profiling both ",(0,s.jsx)(n.code,{children:"ustr"})," and the enhanced version of ",(0,s.jsx)(n.code,{children:"string-cache"}),", it became apparent that the performance was still below expectations compared to the approach I am going to explain below."]}),"\n",(0,s.jsx)(n.p,{children:"Some preliminary guesses for the sub-par performance are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Hashing - the interners need to hash the string for deduplication"}),"\n",(0,s.jsx)(n.li,{children:'Indirection - we need to read the string value from a "far away" heap, which is not cache friendly'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"string-inlining",children:"String Inlining"}),"\n",(0,s.jsx)(n.p,{children:"So we are back to the initial problem of having to allocate lots of strings.\nFortunately, there is a partial solution to this problem if we look at what kind of data we are dealing with:\nshort JavaScript variable names and some short strings.\nThere is a technique called string inlining,\nwhere we store all of the bytes of a string on the stack."}),"\n",(0,s.jsx)(n.p,{children:"In essence, we want the following enum to store our string."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"enum Str {\n    Static(&'static str),\n    Inline(InlineReprensation),\n    Heap(String),\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To minimize the size of the enum, ",(0,s.jsx)(n.code,{children:"InlineRepresentation"})," should have the same size as ",(0,s.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[cfg(all(target_arch = "x86_64", target_pointer_width = "64"))]\n#[test]\nfn test_size() {\n    use std::mem::size_of;\n    assert_eq!(size_of::<String>(), size_of::<InlineReprensation>());\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Many crates in the Rust community aim to optimize memory usage. This is yet another battlefield within the community.\nThe most popular ones are"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://crates.io/crates/smol_str",children:"smol_str"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://crates.io/crates/smartstring",children:"smartstring"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://crates.io/crates/compact_str",children:"compact_str"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://crates.io/crates/flexstr",children:"flexstr"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Each of these crates have unique characteristics and approaches to achieving memory optimization, leading to a variety of trade-offs and considerations when choosing which one to use.\nFor example ",(0,s.jsx)(n.code,{children:"smol_str"})," and ",(0,s.jsx)(n.code,{children:"flexstr"})," clones are O(1).\n",(0,s.jsx)(n.code,{children:"flexstr"})," can store 22 bytes, ",(0,s.jsx)(n.code,{children:"smol_str"})," and ",(0,s.jsx)(n.code,{children:"smartstring"})," can store 23 bytes, and ",(0,s.jsx)(n.code,{children:"compact_str"})," can store 24 bytes on 64-bit systems."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://fasterthanli.me",children:"https://fasterthanli.me"})," has a ",(0,s.jsx)(n.a,{href:"https://fasterthanli.me/articles/small-strings-in-rust",children:"deep dive"})," on this topic."]}),"\n",(0,s.jsxs)(n.p,{children:["Changing ",(0,s.jsx)(n.code,{children:"String"})," to ",(0,s.jsx)(n.code,{children:"compact_str::CompactStr"})," reduced memory allocations by a large amount."]}),"\n",(0,s.jsx)(n.h2,{id:"lexer",children:"Lexer"}),"\n",(0,s.jsx)(n.h3,{id:"token",children:"Token"}),"\n",(0,s.jsx)(n.p,{children:"The job of the lexer (also known as tokenizer) is to turn source text into structured data called a token."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct Token {\n    pub kind: Kind,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"To make it easier to work with, a token kind is typically defined as an enum in Rust. The variants of the enums hold the corresponding data for each token."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum Kind {\n    // Keywords\n    For,\n    While,\n    ...\n    // Literals\n    String(String),\n    Num(f64),\n    ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This enum currently uses 32 bytes, and a lexer often need to construct millions of this token ",(0,s.jsx)(n.code,{children:"Kind"}),".\nEvery time it constructs a ",(0,s.jsx)(n.code,{children:"Kind::For"})," or ",(0,s.jsx)(n.code,{children:"Kind::While"}),", it has to allocate 32 bytes of memory on the stack."]}),"\n",(0,s.jsxs)(n.p,{children:["A clever way to improve this is to break up the enum variant to keep ",(0,s.jsx)(n.code,{children:"Kind"})," to a single byte and move the values into another enum,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct Token<'a> {\n    pub kind: Kind,\n    pub value: TokenValue\n}\n\npub enum TokenValue {\n    None,\n    String(String),\n    Num(f64),\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Since we control all the parsing code, it is our job to keep this safe by always declaring the corresponding token value to its kind."}),"\n",(0,s.jsxs)(n.p,{children:["While a ",(0,s.jsx)(n.code,{children:"TokenValue"})," of 32 bytes is already quite small, it may still have a negative impact on performance because it is allocated frequently."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's take a look at the ",(0,s.jsx)(n.code,{children:"String"}),' type and see what we can find, by using the "go-to definition" in our code editors,\nwe\'ll go through ',(0,s.jsx)(n.code,{children:"String"})," -> ",(0,s.jsx)(n.code,{children:"Vec"})," -> ",(0,s.jsx)(n.code,{children:"RawVec"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct String {\n    vec: Vec<u8>,\n}\n\npub struct Vec {\n    buf: RawVec<T, A>,\n    len: usize,\n}\n\npub struct RawVec {\n    ptr: Unique<T>,\n    cap: usize,\n    alloc: A,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As advertised, a ",(0,s.jsx)(n.code,{children:"String"})," is just a ",(0,s.jsx)(n.code,{children:"Vec"})," of ",(0,s.jsx)(n.code,{children:"u8"}),"s, and a ",(0,s.jsx)(n.code,{children:"Vec"})," has a length and a capacity field.\nSince we are never going to mutate this string, an optimization in terms of memory usage would be to drop the cap field and use a string slice (",(0,s.jsx)(n.code,{children:"&str"}),") instead."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum TokenValue<'a> {\n    None,\n    String(&'a str),\n    Num(f64),\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"TokenValue"})," becomes 24 bytes."]}),"\n",(0,s.jsxs)(n.p,{children:["While using a string slice instead of String in ",(0,s.jsx)(n.code,{children:"TokenValue"})," would reduce memory usage, it does come with the downside of adding a lifetime annotation.\nThis can lead to issues with the borrow checker and the lifetime annotation will propagate to the rest of the codebase, making our code somewhat difficult to manage.\nI lost the borrow checking game 8 months ago but ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/pull/174",children:"finally won"})," when I revisited this."]}),"\n",(0,s.jsxs)(n.p,{children:["When it makes sense, we can always go for the owned version of the immutable data instead of using references.\nFor example ",(0,s.jsx)(n.code,{children:"Box<str>"})," for ",(0,s.jsx)(n.code,{children:"String"})," and ",(0,s.jsx)(n.code,{children:"Box<[u8]>"})," for ",(0,s.jsx)(n.code,{children:"Vec<u8>"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"In summary, we can always come up with tricks to keep our data structures small,\nand it will sometimes reward us performance improvement."}),"\n",(0,s.jsx)(n.h3,{id:"cow",children:"Cow"}),"\n",(0,s.jsxs)(n.p,{children:["I first encountered the term ",(0,s.jsx)(n.code,{children:"Cow"})," when I was studying jsparagus's code,\nit has an infrastructure called ",(0,s.jsx)(n.a,{href:"https://github.com/mozilla-spidermonkey/jsparagus/blob/212f6bdbc2cae909e7d5cfebf36284560c3c4ef4/crates/parser/src/lexer.rs#L2256",children:(0,s.jsx)(n.code,{children:"AutoCow"})}),"."]}),"\n",(0,s.jsx)(n.p,{children:"I vaguely understood what the code was doing.\nWhen a JavaScript string is being tokenized,\nit allocates a new string when it encounters an escaped sequence or it returns the original string slice if it doesn't:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn finish(&mut self, lexer: &Lexer<'alloc>) -> &'alloc str {\n    match self.value.take() {\n        Some(arena_string) => arena_string.into_bump_str(),\n        None => &self.start[..self.start.len() - lexer.chars.as_str().len()],\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is clever because 99.9% of the time it will not allocate a new string because escaped strings are rare."}),"\n",(0,s.jsxs)(n.p,{children:["But the term ",(0,s.jsx)(n.code,{children:"Cow"}),' or "clone-on-write smart pointer" never made sense to me.']}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"The type Cow is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the Borrow trait."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you are new to Rust (like I was), then this description just doesn't help (I still don't understand what it is talking about)."}),"\n",(0,s.jsxs)(n.p,{children:["It was ",(0,s.jsx)(n.a,{href:"https://twitter.com/zack_overflow/status/1620387950264713216",children:"pointed out to me"})," that ",(0,s.jsx)(n.code,{children:"clone-on-write"})," is\njust a use case of this data structure. A better name should be called ",(0,s.jsx)(n.code,{children:"RefOrOwned"})," because it is a type that contains either\nowned data or a reference."]}),"\n",(0,s.jsx)(n.h3,{id:"simd",children:"SIMD"}),"\n",(0,s.jsxs)(n.p,{children:["When I was going through the old Rust blogs, the ",(0,s.jsx)(n.a,{href:"https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html",children:"Announcing the Portable SIMD Project Group"}),"\ncaught my attention.\nI always wanted to play around with SIMD but never got the chance.\nAfter some research, I found a use case that may apply to a parser:\n",(0,s.jsx)(n.a,{href:"https://lemire.me/blog/2017/01/20/how-quickly-can-you-remove-spaces-from-a-string",children:"How quickly can you remove spaces from a string?"})," by Daniel Lemire.\nSo it turns out this has been done before, in a JSON parser called RapidJSON,\nwhich ",(0,s.jsx)(n.a,{href:"https://rapidjson.org/md_doc_internals.html#SkipwhitespaceWithSIMD",children:"uses SIMD to remove whitespaces"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["So eventually with the help of portable-SIMD and RapidJSON's code,\nnot only did I manage to ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/pull/26",children:"skip whitespaces"}),",\nI also managed to ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/pull/23",children:"skip multi-line comments"})," as well."]}),"\n",(0,s.jsx)(n.p,{children:"Both changes improved the performance by a few percent."}),"\n",(0,s.jsx)(n.h3,{id:"keyword-match",children:"Keyword match"}),"\n",(0,s.jsx)(n.p,{children:"At the top of the performance profile,\nthere is a hot code path that takes about 1 - 2% of the total execution time."}),"\n",(0,s.jsx)(n.p,{children:"It tries to match a string to a JavaScript keyword:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn match_keyword(s: &str) -> Self {\n    match s {\n        "as" => As,\n        "do" => Do,\n        "if" => If,\n        ...\n        "constructor" => Constructor,\n        _ => Ident,\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["With the addition of TypeScript, there are 84 strings for us to match from.\nAfter some research, I found a blog from V8 ",(0,s.jsx)(n.a,{href:"https://v8.dev/blog/scanner",children:"Blazingly fast parsing, part 1: optimizing the scanner"}),",\nit describes its ",(0,s.jsx)(n.a,{href:"https://source.chromium.org/chromium/chromium/src/+/main:v8/src/parsing/keywords-gen.h",children:"keyword matching code"})," in detail."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Since the list of keywords is static, we can compute a perfect hash function that for each identifier gives us at most one candidate keyword. V8 uses gperf to compute this function. The result computes a hash from the length and first two identifier characters to find the single candidate keyword. We only compare the identifier with the keyword if the length of that keyword matches the input identifier length."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["So a quick hash plus an integer comparison should be faster than 84 string comparisons.\nBut we tried ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/pull/140",children:"again"})," and ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/pull/171",children:"again"})," to no avail."]}),"\n",(0,s.jsxs)(n.p,{children:["As it turns out, ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/issues/151#issuecomment-1464818336",children:"LLVM already optimized our code"}),".\nBy using ",(0,s.jsx)(n.code,{children:"--emit=llvm-ir"})," on ",(0,s.jsx)(n.code,{children:"rustc"}),", we find the relevant code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'  switch i64 %s.1, label %bb6 [\n    i64 2, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit.i"\n    i64 3, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit280.i"\n    i64 4, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit325.i"\n    i64 5, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit380.i"\n    i64 6, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit450.i"\n    i64 7, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit540.i"\n    i64 8, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit590.i"\n    i64 9, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit625.i"\n    i64 10, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit655.i"\n    i64 11, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit665.i"\n  ], !dbg !191362\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"%s"})," is the string, ",(0,s.jsx)(n.code,{children:"%s.1"})," is its length ... it is branching on the string length! The compiler is smarter than us \ud83d\ude03."]}),"\n",(0,s.jsx)(n.p,{children:"(Yes, we got so serious with this so we started looking at LLVM IR and assembly code.)"}),"\n",(0,s.jsxs)(n.p,{children:["Later on, ",(0,s.jsx)(n.a,{href:"https://twitter.com/strager",children:"@strager"})," posted a very educational YouTube video ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=DMQ_HcNSOAI",children:"Faster than Rust and C++: the PERFECT hash table "})," on this topic.\nThe video taught us a systematic approach to reasoning about fine-tuning performance problems"]}),"\n",(0,s.jsx)(n.p,{children:"In the end, we concluded that the simple keyword match is enough for us since it was only about 1 - 2% of the performance,\nand the effort is not worth it after spending a few days on it - Rust does not have all the pieces we need to build this perfect hashmap."}),"\n",(0,s.jsx)(n.h2,{id:"linter",children:"Linter"}),"\n",(0,s.jsx)(n.p,{children:"A linter is a program that analyzes the source code for problems."}),"\n",(0,s.jsxs)(n.p,{children:["The simplest linter visits each AST node and checks for rules.\n",(0,s.jsx)(n.a,{href:"https://rust-unofficial.github.io/patterns/patterns/behavioural/visitor.html",children:"The visitor pattern"})," can be used:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub trait Visit<'a>: Sized {\n    // ... lots of visit functions\n\n    fn visit_debugger_statement(&mut self, stmt: &'a DebuggerStatement) {\n        // report error\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parent-pointing-tree",children:"Parent Pointing Tree"}),"\n",(0,s.jsx)(n.p,{children:"It is easy to go down the AST by using visitors, but what if we want to go up the tree to collect some information?"}),"\n",(0,s.jsx)(n.p,{children:"This problem is particularly challenging to solve in Rust, because it is not possible to add a pointer to the nodes of the AST."}),"\n",(0,s.jsxs)(n.p,{children:["Let's forget about ASTs for a second and focus on generic trees with the property of a node having a pointer to its parent.\nTo build a generic tree, each tree node needs to be the same type ",(0,s.jsx)(n.code,{children:"Node"}),", we can reference their parent by using ",(0,s.jsx)(n.code,{children:"Rc"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct Node {\n    parent: Option<Rc<Node>>,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"It is tedious to work with this pattern if we need mutation, and\nit is not performant because the nodes have to be dropped at different times."}),"\n",(0,s.jsxs)(n.p,{children:["A more efficient solution is to use a ",(0,s.jsx)(n.code,{children:"Vec"})," as its backing storage and use indexes for pointers."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct Tree {\n    nodes: Vec<Node>\n}\n\nstruct Node {\n    parent: Option<usize> // index into `nodes`\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://crates.io/crates/indextree",children:(0,s.jsx)(n.code,{children:"indextree"})})," is a nice library for this task."]}),"\n",(0,s.jsxs)(n.p,{children:["Back to our AST, we can build a ",(0,s.jsx)(n.code,{children:"indextree"})," by having the nodes point to an enum that wraps every single kind of AST node.\nWe call this the untyped AST."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct Node<'a> {\n    kind: AstKind<'a>\n}\n\nenum AstKind<'a> {\n    BlockStatement(&'a BlockStatement<'a>),\n    // ...\n    ArrayExpression(&'a ArrayExpression<'a>),\n    // ...\n    Class(&'a Class<'a>),\n    // ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The last missing piece is to have callbacks inside the visitor pattern that builds this tree."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub trait Visit<'a> {\n    fn enter_node(&mut self, _kind: AstKind<'a>) {}\n    fn leave_node(&mut self, _kind: AstKind<'a>) {}\n\n    fn visit_block_statement(&mut self, stmt: &'a BlockStatement<'a>) {\n        let kind = AstKind::BlockStatement(stmt);\n        self.enter_node(kind);\n        self.visit_statements(&stmt.body);\n        self.leave_node(kind);\n    }\n}\n\nimpl<'a> Visit<'a> for TreeBuilder<'a> {\n    fn enter_node(&mut self, kind: AstKind<'a>) {\n        self.push_ast_node(kind);\n    }\n\n    fn leave_node(&mut self, kind: AstKind<'a>) {\n        self.pop_ast_node();\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The final data structure becomes ",(0,s.jsx)(n.code,{children:"indextree::Arena<Node<'a>>"})," where each ",(0,s.jsx)(n.code,{children:"Node"})," has a pointer to an ",(0,s.jsx)(n.code,{children:"AstKind<'a>"}),".\n",(0,s.jsx)(n.code,{children:"indextree::Node::parent"})," can be called to get the parent of any node."]}),"\n",(0,s.jsxs)(n.p,{children:["The nice benefit of making this parent pointing tree is that it becomes convenient to visit AST nodes without having to implement any visitors.\nA linter becomes a simple loop over all the nodes inside the ",(0,s.jsx)(n.code,{children:"indextree"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"for node in nodes {\n    match node.get().kind {\n        AstKind::DebuggerStatement(stmt) => {\n        // report error\n        }\n        _ => {}\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A full example is provided ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/blob/main/crates/oxc_linter/examples/linter.rs",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["At first glance, this process may seem slow and inefficient.\nHowever, visiting the typed AST through a memory arena and pushing a pointer into ",(0,s.jsx)(n.code,{children:"indextree"})," are efficient linear memory access patterns.\nThe current benchmark indicates that this approach is 84 times faster than ESLint, so it is certainly fast enough for our purposes."]}),"\n",(0,s.jsx)(n.h3,{id:"processing-files-in-parallel",children:"Processing files in parallel"}),"\n",(0,s.jsxs)(n.p,{children:["The linter uses the ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/ignore",children:"ignore"})," crate for directory traversal,\nit supports ",(0,s.jsx)(n.code,{children:".gitignore"})," and adds additional ignore files such as ",(0,s.jsx)(n.code,{children:".eslintignore"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A small problem with this crate is that it does not have a parallel interface,\nThere is no ",(0,s.jsx)(n.code,{children:"par_iter"})," for ",(0,s.jsx)(n.code,{children:'ignore::Walk::new(".")'}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Instead, ",(0,s.jsx)(n.a,{href:"https://github.com/Boshen/oxc/blob/b51c2df3cc43b9f7d57380acc1552fac7db75fab/crates/oxc_cli/src/lint/runner.rs#L116-L139",children:"primitives need to be used"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let walk = Walk::new(&self.options);\nrayon::spawn(move || {\n    walk.iter().for_each(|path| {\n        tx_path.send(path).unwrap();\n    });\n});\n\nlet linter = Arc::clone(&self.linter);\nrayon::spawn(move || {\n    while let Ok(path) = rx_path.recv() {\n        let tx_error = tx_error.clone();\n        let linter = Arc::clone(&linter);\n        rayon::spawn(move || {\n            if let Some(diagnostics) = Self::lint_path(&linter, &path) {\n                tx_error.send(diagnostics).unwrap();\n            }\n            drop(tx_error);\n        });\n    }\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"This unlocks a useful feature where we can print all diagnostics in a single thread, which leads us to the final topic of this article."}),"\n",(0,s.jsx)(n.h3,{id:"printing-is-slow",children:"Printing is slow"}),"\n",(0,s.jsx)(n.p,{children:"Printing the diagnostics was fast, but I have been working on this project for so long that it felt like an eternity to print thousands of diagnostic messages every time I run the linter on huge monorepos.\nSo I started searching through the Rust GitHub issues and eventually found the relevant ones:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/rust-lang/rust/issues/60673",children:"io::Stdout should use block buffering when appropriate"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/rust-lang/rust/issues/106133",children:"stdin and stdout performance considerations are not documented"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In summary, a ",(0,s.jsx)(n.code,{children:"println!"})," call will lock ",(0,s.jsx)(n.code,{children:"stdout"})," every time it encounters a newline, this is called line buffering.\nTo make things print faster, we need to opt-in for block buffering which is ",(0,s.jsx)(n.a,{href:"https://rust-cli.github.io/book/tutorial/output.html#a-note-on-printing-performance",children:"documented here"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use std::io::{self, Write};\n\nlet stdout = io::stdout(); // get the global stdout entity\nlet mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer\nwriteln!(handle, "foo: {}", 42); // add `?` if you care about errors here\n'})}),"\n",(0,s.jsx)(n.p,{children:"Or acquire the lock on stdout."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let stdout = io::stdout(); // get the global stdout entity\nlet mut handle = stdout.lock(); // acquire a lock on it\nwriteln!(handle, "foo: {}", 42); // add `?` if you care about errors here\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7660:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var s=t(959);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);